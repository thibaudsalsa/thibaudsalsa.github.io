{"version":3,"sources":["parser.js"],"names":["parser","hasTerminalParent","parse","tokens","options","root","tagName","children","state","cursor","stack","terminals","tagParents","currentIndex","length","parentTagName","nodes","len","token","type","push","tagToken","content","toLowerCase","close","item","pop","endToken","isClosingTag","closingTags","shouldRewindToAutoClose","closingTagAncestorBreakers","slice","previousIndex","attributes","attrToken","hasChildren","voidTags","innerState"],"mappings":"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","file":"parser.js","sourcesContent":["import {arrayIncludes} from './compat'\n\nexport default function parser (tokens, options) {\n  const root = {tagName: null, children: []}\n  const state = {tokens, options, cursor: 0, stack: [root]}\n  parse(state)\n  return root.children\n}\n\nexport function hasTerminalParent (tagName, stack, terminals) {\n  const tagParents = terminals[tagName]\n  if (tagParents) {\n    let currentIndex = stack.length - 1\n    while (currentIndex >= 0) {\n      const parentTagName = stack[currentIndex].tagName\n      if (parentTagName === tagName) {\n        break\n      }\n      if (arrayIncludes(tagParents, parentTagName)) {\n        return true\n      }\n      currentIndex--\n    }\n  }\n  return false\n}\n\nexport function parse (state) {\n  const {tokens, options} = state\n  let {stack} = state\n  let nodes = stack[stack.length - 1].children\n  const len = tokens.length\n  let {cursor} = state\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      nodes.push(token)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content.toLowerCase()\n    if (token.close) {\n      let item\n      while ((item = stack.pop())) {\n        if (tagName === item.tagName) break\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      break\n    }\n\n    const isClosingTag = arrayIncludes(options.closingTags, tagName)\n    let shouldRewindToAutoClose = isClosingTag\n    if (shouldRewindToAutoClose) {\n      const { closingTagAncestorBreakers: terminals } = options\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals)\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    let attributes = []\n    let attrToken\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n      attributes.push(attrToken.content)\n      cursor++\n    }\n\n    cursor++\n    const children = []\n    nodes.push({\n      type: 'element',\n      tagName: tagToken.content,\n      attributes,\n      children\n    })\n\n    const hasChildren = !(attrToken.close || arrayIncludes(options.voidTags, tagName))\n    if (hasChildren) {\n      stack.push({tagName, children})\n      const innerState = {tokens, options, cursor, stack}\n      parse(innerState)\n      cursor = innerState.cursor\n    }\n  }\n  state.cursor = cursor\n}\n"]}