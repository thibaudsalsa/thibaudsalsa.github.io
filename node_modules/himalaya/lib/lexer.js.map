{"version":3,"sources":["lexer.js"],"names":["lexer","lex","lexText","lexComment","lexTag","isWhitespaceChar","lexTagName","lexTagAttributes","lexSkipTag","str","options","state","cursor","tokens","len","length","isText","charAt","isComment","tagName","safeTag","toLowerCase","childlessTags","textEnd","indexOf","type","content","slice","push","commentEnd","secondChar","close","firstChar","whitespace","char","test","start","isTagChar","end","quote","wordBegin","words","isQuoteEnd","isTagEnd","isWordEnd","isQuoteStart","wLen","i","word","isNotPair","secondWord","newWord","thirdWord","index","nextTag","tagState","name","safeTagName","openTag","closeTag"],"mappings":"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","file":"lexer.js","sourcesContent":["import {\n  startsWith,\n  endsWith,\n  stringIncludes,\n  arrayIncludes\n} from './compat'\n\nexport default function lexer (str, options) {\n  const state = {str, options, cursor: 0, tokens: []}\n  lex(state)\n  return state.tokens\n}\n\nexport function lex (state) {\n  const {str} = state\n  const len = str.length\n  while (state.cursor < len) {\n    const isText = str.charAt(state.cursor) !== '<'\n    if (isText) {\n      lexText(state)\n      continue\n    }\n\n    const isComment = startsWith(str, '!--', state.cursor + 1)\n    if (isComment) {\n      lexComment(state)\n      continue\n    }\n\n    const tagName = lexTag(state)\n    if (tagName) {\n      const safeTag = tagName.toLowerCase()\n      const {childlessTags} = state.options\n      if (arrayIncludes(childlessTags, safeTag)) {\n        lexSkipTag(tagName, state)\n      }\n    }\n  }\n}\n\nexport function lexText (state) {\n  const {str, cursor} = state\n  const textEnd = str.indexOf('<', cursor)\n  const type = 'text'\n  if (textEnd === -1) {\n    // there is only text left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  if (textEnd === cursor) return\n\n  const content = str.slice(cursor, textEnd)\n  state.cursor = textEnd\n  state.tokens.push({type, content})\n}\n\nexport function lexComment (state) {\n  state.cursor += 4 // \"<!--\".length\n  const {str, cursor} = state\n  const commentEnd = str.indexOf('-->', cursor)\n  const type = 'comment'\n  if (commentEnd === -1) {\n    // there is only the comment left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  const content = str.slice(cursor, commentEnd)\n  state.cursor = commentEnd + 3 // \"-->\".length\n  state.tokens.push({type, content})\n}\n\nexport function lexTag (state) {\n  const {str} = state\n  {\n    const secondChar = str.charAt(state.cursor + 1)\n    const close = secondChar === '/'\n    state.tokens.push({type: 'tag-start', close})\n    state.cursor += close ? 2 : 1\n  }\n  const tagName = lexTagName(state)\n  lexTagAttributes(state)\n  {\n    const firstChar = str.charAt(state.cursor)\n    const close = firstChar === '/'\n    state.tokens.push({type: 'tag-end', close})\n    state.cursor += close ? 2 : 1\n  }\n  return tagName\n}\n\n// There is one regex for whitespace.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nconst whitespace = /\\s/\nexport function isWhitespaceChar (char) {\n  return whitespace.test(char)\n}\n\nexport function lexTagName (state) {\n  const {str, cursor} = state\n  const len = str.length\n  let start = cursor\n  while (start < len) {\n    const char = str.charAt(start)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (isTagChar) break\n    start++\n  }\n\n  let end = start + 1\n  while (end < len) {\n    const char = str.charAt(end)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (!isTagChar) break\n    end++\n  }\n\n  state.cursor = end\n  const tagName = str.slice(start, end)\n  state.tokens.push({type: 'tag', content: tagName})\n  return tagName\n}\n\nexport function lexTagAttributes (state) {\n  const {str, tokens} = state\n  let cursor = state.cursor\n  let quote = null // null, single-, or double-quote\n  let wordBegin = cursor // index of word start\n  const words = [] // \"key\", \"key=value\", \"key='value'\", etc\n  const len = str.length\n  while (cursor < len) {\n    const char = str.charAt(cursor)\n    if (quote) {\n      const isQuoteEnd = char === quote\n      if (isQuoteEnd) {\n        quote = null\n      }\n      cursor++\n      continue\n    }\n\n    const isTagEnd = char === '/' || char === '>'\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      break\n    }\n\n    const isWordEnd = isWhitespaceChar(char)\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      wordBegin = cursor + 1\n      cursor++\n      continue\n    }\n\n    const isQuoteStart = char === '\\'' || char === '\"'\n    if (isQuoteStart) {\n      quote = char\n      cursor++\n      continue\n    }\n\n    cursor++\n  }\n  state.cursor = cursor\n\n  const wLen = words.length\n  const type = 'attribute'\n  for (let i = 0; i < wLen; i++) {\n    const word = words[i]\n    if (!(word && word.length)) continue\n    const isNotPair = word.indexOf('=') === -1\n    if (isNotPair) {\n      const secondWord = words[i + 1]\n      if (secondWord && startsWith(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          const newWord = word + secondWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n        const thirdWord = words[i + 2]\n        i += 1\n        if (thirdWord) {\n          const newWord = word + '=' + thirdWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n      }\n    }\n    if (endsWith(word, '=')) {\n      const secondWord = words[i + 1]\n      if (secondWord && !stringIncludes(secondWord, '=')) {\n        const newWord = word + secondWord\n        tokens.push({type, content: newWord})\n        i += 1\n        continue\n      }\n\n      const newWord = word.slice(0, -1)\n      tokens.push({type, content: newWord})\n      continue\n    }\n\n    tokens.push({type, content: word})\n  }\n}\n\nexport function lexSkipTag (tagName, state) {\n  const {str, cursor, tokens} = state\n  const len = str.length\n  let index = cursor\n  while (index < len) {\n    const nextTag = str.indexOf('</', index)\n    if (nextTag === -1) {\n      lexText(state)\n      break\n    }\n\n    const tagState = {str, cursor: nextTag + 2, tokens: []}\n    const name = lexTagName(tagState)\n    const safeTagName = tagName.toLowerCase()\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.cursor\n      continue\n    }\n\n    const content = str.slice(cursor, nextTag)\n    tokens.push({type: 'text', content})\n    const openTag = {type: 'tag-start', close: true}\n    const closeTag = {type: 'tag-end', close: false}\n    lexTagAttributes(tagState)\n    tokens.push(openTag, ...tagState.tokens, closeTag)\n    state.cursor = tagState.cursor + 1\n    break\n  }\n}\n"]}