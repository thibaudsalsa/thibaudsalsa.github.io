{"version":3,"sources":["formats/v0.js"],"names":["format","capitalize","camelCase","castValue","unquote","splitHead","formatAttributes","formatStyles","nodes","map","type","node","tagName","toLowerCase","attributes","children","content","str","charAt","toUpperCase","slice","split","reduce","word","num","isNaN","car","end","length","isQuoteStart","sep","idx","indexOf","attrs","pair","trim","key","value","className","style","dataset","prop","rule","styles","keyValue","rawKey","rawValue"],"mappings":"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","file":"v0.js","sourcesContent":["/*\n  This format adheres to the v0 ASP spec.\n*/\nimport {startsWith} from '../compat'\n\nexport default function format (nodes) {\n  return nodes.map(node => {\n    const type = capitalize(node.type)\n    if (type === 'Element') {\n      const tagName = node.tagName.toLowerCase()\n      const attributes = formatAttributes(node.attributes)\n      const children = format(node.children)\n      return {type, tagName, attributes, children}\n    }\n\n    return {type, content: node.content}\n  })\n}\n\nexport function capitalize (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function camelCase (str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word.charAt(0).toUpperCase() + word.slice(1)\n  })\n}\n\nexport function castValue (str) {\n  if (typeof str !== 'string') return str\n  if (str === '') return str\n  const num = +str\n  if (!isNaN(num)) return num\n  return str\n}\n\nexport function unquote (str) {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}\n\nexport function splitHead (str, sep) {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nexport function formatAttributes (attributes) {\n  return attributes.reduce((attrs, pair) => {\n    let [key, value] = splitHead(pair.trim(), '=')\n    value = value ? unquote(value) : key\n    if (key === 'class') {\n      attrs.className = value.split(' ')\n    } else if (key === 'style') {\n      attrs.style = formatStyles(value)\n    } else if (startsWith(key, 'data-')) {\n      attrs.dataset = attrs.dataset || {}\n      const prop = camelCase(key.slice(5))\n      attrs.dataset[prop] = castValue(value)\n    } else {\n      attrs[camelCase(key)] = castValue(value)\n    }\n    return attrs\n  }, {})\n}\n\nexport function formatStyles (str) {\n  return str.trim().split(';')\n    .map(rule => rule.trim().split(':'))\n    .reduce((styles, keyValue) => {\n      const [rawKey, rawValue] = keyValue\n      if (rawValue) {\n        const key = camelCase(rawKey.trim())\n        const value = castValue(rawValue.trim())\n        styles[key] = value\n      }\n      return styles\n    }, {})\n}\n"]}